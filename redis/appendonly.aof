*2
$6
SELECT
$1
0
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:paused
$30
{midway-bull}:test:meta-paused
$21
{midway-bull}:test:id
$26
{midway-bull}:test:delayed
$27
{midway-bull}:test:priority
$19
{midway-bull}:test:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703474739640}
$13
1703474739640
$1
0
$1
0
$1
0
$5
LPUSH
$36
a263813e-1fa9-4c80-9b4b-c53a03111566
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$26
{midway-bull}:test:stalled
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$25
{midway-bull}:test:failed
$32
{midway-bull}:test:stalled-check
$30
{midway-bull}:test:meta-paused
$25
{midway-bull}:test:paused
$1
1
$19
{midway-bull}:test:
$13
1703474739677
$5
30000
*3
$9
RPOPLPUSH
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$27
{midway-bull}:test:priority
$62
{midway-bull}:test:active@a263813e-1fa9-4c80-9b4b-c53a03111566
$26
{midway-bull}:test:stalled
$26
{midway-bull}:test:limiter
$26
{midway-bull}:test:delayed
$26
{midway-bull}:test:drained
$19
{midway-bull}:test:
$36
a263813e-1fa9-4c80-9b4b-c53a03111566
$5
30000
$13
1703474739685
$1
1
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$25
{midway-bull}:test:active
$28
{midway-bull}:test:completed
$20
{midway-bull}:test:1
$23
{midway-bull}:test:wait
$27
{midway-bull}:test:priority
$62
{midway-bull}:test:active@a263813e-1fa9-4c80-9b4b-c53a03111566
$26
{midway-bull}:test:delayed
$26
{midway-bull}:test:stalled
$36
{midway-bull}:test:metrics:completed
$1
1
$13
1703474739694
$11
returnvalue
$4
null
$36
a263813e-1fa9-4c80-9b4b-c53a03111566
$10
Þ ¥count
$13
{"jobId":"1"}
$1
1
$19
{midway-bull}:test:
$5
30000
$36
a263813e-1fa9-4c80-9b4b-c53a03111566
$0

*16
$4
EVAL
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$27
{midway-bull}:test:priority
$62
{midway-bull}:test:active@a263813e-1fa9-4c80-9b4b-c53a03111566
$26
{midway-bull}:test:stalled
$26
{midway-bull}:test:limiter
$26
{midway-bull}:test:delayed
$26
{midway-bull}:test:drained
$19
{midway-bull}:test:
$36
a263813e-1fa9-4c80-9b4b-c53a03111566
$5
30000
$13
1703474739703
$0

*12
$4
EVAL
$1753
--[[
  Updates the delay set, by picking a delayed job that should
  be processed now.

     Input:
      KEYS[1] 'delayed'
      KEYS[2] 'active'
      KEYS[3] 'wait'
      KEYS[4] 'priority'

      KEYS[5] 'paused'
      KEYS[6] 'meta-paused'

      ARGV[1]  queue.toKey('')
      ARGV[2]  delayed timestamp
      ARGV[3]  queue token

     Events:
      'removed'
]]
local rcall = redis.call;

-- Try to get as much as 1000 jobs at once
local jobs = rcall("ZRANGEBYSCORE", KEYS[1], 0, tonumber(ARGV[2]) * 0x1000, "LIMIT", 0, 1000)

if(#jobs > 0) then
  rcall("ZREM", KEYS[1], unpack(jobs))

  -- check if we need to use push in paused instead of waiting
  local target;
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    target = KEYS[3]
  else
    target = KEYS[5]
  end

  for _, jobId in ipairs(jobs) do
    -- Is this really needed?
    rcall("LREM", KEYS[2], 0, jobId)

    local priority = tonumber(rcall("HGET", ARGV[1] .. jobId, "priority")) or 0
  
    if priority == 0 then
      -- LIFO or FIFO
      rcall("LPUSH", target, jobId)
    else
      -- Priority add
      rcall("ZADD", KEYS[4], priority, jobId)
      local count = rcall("ZCOUNT", KEYS[4], 0, priority)
  
      local len = rcall("LLEN", target)
      local id = rcall("LINDEX", target, len - (count-1))
      if id then
        rcall("LINSERT", target, "BEFORE", id, jobId)
      else
        rcall("RPUSH", target, jobId)
      end
    end
  
    -- Emit waiting event (wait..ing@token)
    rcall("PUBLISH", KEYS[3] .. "ing@" .. ARGV[3], jobId)
    rcall("HSET", ARGV[1] .. jobId, "delay", 0)
  end
end

local nextTimestamp = rcall("ZRANGE", KEYS[1], 0, 0, "WITHSCORES")[2]
if(nextTimestamp ~= nil) then
  rcall("PUBLISH", KEYS[1], nextTimestamp / 0x1000)
end
return nextTimestamp

$1
6
$26
{midway-bull}:test:delayed
$25
{midway-bull}:test:active
$23
{midway-bull}:test:wait
$27
{midway-bull}:test:priority
$25
{midway-bull}:test:paused
$30
{midway-bull}:test:meta-paused
$19
{midway-bull}:test:
$13
1703474744678
$36
a263813e-1fa9-4c80-9b4b-c53a03111566
*2
$3
DEL
$32
{midway-bull}:test:stalled-check
*14
$4
EVAL
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$26
{midway-bull}:test:stalled
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$25
{midway-bull}:test:failed
$32
{midway-bull}:test:stalled-check
$30
{midway-bull}:test:meta-paused
$25
{midway-bull}:test:paused
$1
1
$19
{midway-bull}:test:
$13
1703474769682
$5
30000
*2
$3
DEL
$32
{midway-bull}:test:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$26
{midway-bull}:test:stalled
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$25
{midway-bull}:test:failed
$32
{midway-bull}:test:stalled-check
$30
{midway-bull}:test:meta-paused
$25
{midway-bull}:test:paused
$1
1
$19
{midway-bull}:test:
$13
1703474799683
$5
30000
*2
$3
DEL
$32
{midway-bull}:test:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$26
{midway-bull}:test:stalled
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$25
{midway-bull}:test:failed
$32
{midway-bull}:test:stalled-check
$30
{midway-bull}:test:meta-paused
$25
{midway-bull}:test:paused
$1
1
$19
{midway-bull}:test:
$13
1703474829685
$5
30000
*2
$3
DEL
$32
{midway-bull}:test:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$26
{midway-bull}:test:stalled
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$25
{midway-bull}:test:failed
$32
{midway-bull}:test:stalled-check
$30
{midway-bull}:test:meta-paused
$25
{midway-bull}:test:paused
$1
1
$19
{midway-bull}:test:
$13
1703474859686
$5
30000
*2
$3
DEL
$32
{midway-bull}:test:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$26
{midway-bull}:test:stalled
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$25
{midway-bull}:test:failed
$32
{midway-bull}:test:stalled-check
$30
{midway-bull}:test:meta-paused
$25
{midway-bull}:test:paused
$1
1
$19
{midway-bull}:test:
$13
1703474889687
$5
30000
*2
$3
DEL
$32
{midway-bull}:test:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$26
{midway-bull}:test:stalled
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$25
{midway-bull}:test:failed
$32
{midway-bull}:test:stalled-check
$30
{midway-bull}:test:meta-paused
$25
{midway-bull}:test:paused
$1
1
$19
{midway-bull}:test:
$13
1703474919688
$5
30000
*2
$3
DEL
$32
{midway-bull}:test:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$26
{midway-bull}:test:stalled
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$25
{midway-bull}:test:failed
$32
{midway-bull}:test:stalled-check
$30
{midway-bull}:test:meta-paused
$25
{midway-bull}:test:paused
$1
1
$19
{midway-bull}:test:
$13
1703474949689
$5
30000
*2
$3
DEL
$32
{midway-bull}:test:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:paused
$30
{midway-bull}:test:meta-paused
$21
{midway-bull}:test:id
$26
{midway-bull}:test:delayed
$27
{midway-bull}:test:priority
$19
{midway-bull}:test:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703475002901}
$13
1703475002901
$1
0
$1
0
$1
0
$5
LPUSH
$36
2735c8c2-e29d-4029-9592-40e3e254b90f
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$26
{midway-bull}:test:stalled
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$25
{midway-bull}:test:failed
$32
{midway-bull}:test:stalled-check
$30
{midway-bull}:test:meta-paused
$25
{midway-bull}:test:paused
$1
1
$19
{midway-bull}:test:
$13
1703475002979
$5
30000
*3
$9
RPOPLPUSH
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$27
{midway-bull}:test:priority
$62
{midway-bull}:test:active@2735c8c2-e29d-4029-9592-40e3e254b90f
$26
{midway-bull}:test:stalled
$26
{midway-bull}:test:limiter
$26
{midway-bull}:test:delayed
$26
{midway-bull}:test:drained
$19
{midway-bull}:test:
$36
2735c8c2-e29d-4029-9592-40e3e254b90f
$5
30000
$13
1703475002989
$1
2
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$25
{midway-bull}:test:active
$28
{midway-bull}:test:completed
$20
{midway-bull}:test:2
$23
{midway-bull}:test:wait
$27
{midway-bull}:test:priority
$62
{midway-bull}:test:active@2735c8c2-e29d-4029-9592-40e3e254b90f
$26
{midway-bull}:test:delayed
$26
{midway-bull}:test:stalled
$36
{midway-bull}:test:metrics:completed
$1
2
$13
1703475003002
$11
returnvalue
$4
null
$36
2735c8c2-e29d-4029-9592-40e3e254b90f
$10
Þ ¥count
$13
{"jobId":"2"}
$1
1
$19
{midway-bull}:test:
$5
30000
$36
2735c8c2-e29d-4029-9592-40e3e254b90f
$0

*2
$3
DEL
$32
{midway-bull}:test:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$26
{midway-bull}:test:stalled
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$25
{midway-bull}:test:failed
$32
{midway-bull}:test:stalled-check
$30
{midway-bull}:test:meta-paused
$25
{midway-bull}:test:paused
$1
1
$19
{midway-bull}:test:
$13
1703475032988
$5
30000
*2
$3
DEL
$32
{midway-bull}:test:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:paused
$30
{midway-bull}:test:meta-paused
$21
{midway-bull}:test:id
$26
{midway-bull}:test:delayed
$27
{midway-bull}:test:priority
$19
{midway-bull}:test:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703475089977}
$13
1703475089977
$1
0
$1
0
$1
0
$5
LPUSH
$36
b8597693-66b3-4d73-abf0-58ab83a99071
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$26
{midway-bull}:test:stalled
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$25
{midway-bull}:test:failed
$32
{midway-bull}:test:stalled-check
$30
{midway-bull}:test:meta-paused
$25
{midway-bull}:test:paused
$1
1
$19
{midway-bull}:test:
$13
1703475089987
$5
30000
*3
$9
RPOPLPUSH
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$27
{midway-bull}:test:priority
$62
{midway-bull}:test:active@b8597693-66b3-4d73-abf0-58ab83a99071
$26
{midway-bull}:test:stalled
$26
{midway-bull}:test:limiter
$26
{midway-bull}:test:delayed
$26
{midway-bull}:test:drained
$19
{midway-bull}:test:
$36
b8597693-66b3-4d73-abf0-58ab83a99071
$5
30000
$13
1703475089991
$1
3
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$25
{midway-bull}:test:active
$28
{midway-bull}:test:completed
$20
{midway-bull}:test:3
$23
{midway-bull}:test:wait
$27
{midway-bull}:test:priority
$62
{midway-bull}:test:active@b8597693-66b3-4d73-abf0-58ab83a99071
$26
{midway-bull}:test:delayed
$26
{midway-bull}:test:stalled
$36
{midway-bull}:test:metrics:completed
$1
3
$13
1703475089997
$11
returnvalue
$4
null
$36
b8597693-66b3-4d73-abf0-58ab83a99071
$10
Þ ¥count
$13
{"jobId":"3"}
$1
1
$19
{midway-bull}:test:
$5
30000
$36
b8597693-66b3-4d73-abf0-58ab83a99071
$0

*2
$3
DEL
$32
{midway-bull}:test:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$26
{midway-bull}:test:stalled
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$25
{midway-bull}:test:failed
$32
{midway-bull}:test:stalled-check
$30
{midway-bull}:test:meta-paused
$25
{midway-bull}:test:paused
$1
1
$19
{midway-bull}:test:
$13
1703475119993
$5
30000
*2
$3
DEL
$32
{midway-bull}:test:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:paused
$30
{midway-bull}:test:meta-paused
$21
{midway-bull}:test:id
$26
{midway-bull}:test:delayed
$27
{midway-bull}:test:priority
$19
{midway-bull}:test:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703475157576}
$13
1703475157576
$1
0
$1
0
$1
0
$5
LPUSH
$36
006e947d-78b7-4505-aa11-a15f1b0d25a2
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$26
{midway-bull}:test:stalled
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$25
{midway-bull}:test:failed
$32
{midway-bull}:test:stalled-check
$30
{midway-bull}:test:meta-paused
$25
{midway-bull}:test:paused
$1
1
$19
{midway-bull}:test:
$13
1703475157659
$5
30000
*3
$9
RPOPLPUSH
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$27
{midway-bull}:test:priority
$62
{midway-bull}:test:active@006e947d-78b7-4505-aa11-a15f1b0d25a2
$26
{midway-bull}:test:stalled
$26
{midway-bull}:test:limiter
$26
{midway-bull}:test:delayed
$26
{midway-bull}:test:drained
$19
{midway-bull}:test:
$36
006e947d-78b7-4505-aa11-a15f1b0d25a2
$5
30000
$13
1703475157674
$1
4
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$25
{midway-bull}:test:active
$28
{midway-bull}:test:completed
$20
{midway-bull}:test:4
$23
{midway-bull}:test:wait
$27
{midway-bull}:test:priority
$62
{midway-bull}:test:active@006e947d-78b7-4505-aa11-a15f1b0d25a2
$26
{midway-bull}:test:delayed
$26
{midway-bull}:test:stalled
$36
{midway-bull}:test:metrics:completed
$1
4
$13
1703475157689
$11
returnvalue
$4
null
$36
006e947d-78b7-4505-aa11-a15f1b0d25a2
$10
Þ ¥count
$13
{"jobId":"4"}
$1
1
$19
{midway-bull}:test:
$5
30000
$36
006e947d-78b7-4505-aa11-a15f1b0d25a2
$0

*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:paused
$30
{midway-bull}:test:meta-paused
$21
{midway-bull}:test:id
$26
{midway-bull}:test:delayed
$27
{midway-bull}:test:priority
$19
{midway-bull}:test:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703475169838}
$13
1703475169838
$1
0
$1
0
$1
0
$5
LPUSH
$36
81e0ab7f-8ecf-4658-b2b7-d0d45f04f879
*3
$9
RPOPLPUSH
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$27
{midway-bull}:test:priority
$62
{midway-bull}:test:active@81e0ab7f-8ecf-4658-b2b7-d0d45f04f879
$26
{midway-bull}:test:stalled
$26
{midway-bull}:test:limiter
$26
{midway-bull}:test:delayed
$26
{midway-bull}:test:drained
$19
{midway-bull}:test:
$36
81e0ab7f-8ecf-4658-b2b7-d0d45f04f879
$5
30000
$13
1703475169850
$1
5
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$25
{midway-bull}:test:active
$28
{midway-bull}:test:completed
$20
{midway-bull}:test:5
$23
{midway-bull}:test:wait
$27
{midway-bull}:test:priority
$62
{midway-bull}:test:active@81e0ab7f-8ecf-4658-b2b7-d0d45f04f879
$26
{midway-bull}:test:delayed
$26
{midway-bull}:test:stalled
$36
{midway-bull}:test:metrics:completed
$1
5
$13
1703475169857
$11
returnvalue
$4
null
$36
81e0ab7f-8ecf-4658-b2b7-d0d45f04f879
$10
Þ ¥count
$13
{"jobId":"5"}
$1
1
$19
{midway-bull}:test:
$5
30000
$36
81e0ab7f-8ecf-4658-b2b7-d0d45f04f879
$0

*2
$3
DEL
$32
{midway-bull}:test:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$26
{midway-bull}:test:stalled
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$25
{midway-bull}:test:failed
$32
{midway-bull}:test:stalled-check
$30
{midway-bull}:test:meta-paused
$25
{midway-bull}:test:paused
$1
1
$19
{midway-bull}:test:
$13
1703475199850
$5
30000
*2
$3
DEL
$32
{midway-bull}:test:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$26
{midway-bull}:test:stalled
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$25
{midway-bull}:test:failed
$32
{midway-bull}:test:stalled-check
$30
{midway-bull}:test:meta-paused
$25
{midway-bull}:test:paused
$1
1
$19
{midway-bull}:test:
$13
1703475229851
$5
30000
*2
$3
DEL
$32
{midway-bull}:test:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$26
{midway-bull}:test:stalled
$23
{midway-bull}:test:wait
$25
{midway-bull}:test:active
$25
{midway-bull}:test:failed
$32
{midway-bull}:test:stalled-check
$30
{midway-bull}:test:meta-paused
$25
{midway-bull}:test:paused
$1
1
$19
{midway-bull}:test:
$13
1703475259852
$5
30000
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703475281595
$5
30000
*2
$3
DEL
$32
{midway-bull}:test:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703475309777}
$13
1703475309777
$1
0
$1
0
$1
0
$5
LPUSH
$36
98e89750-edfd-4170-b1ba-60450b75cae4
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@98e89750-edfd-4170-b1ba-60450b75cae4
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
98e89750-edfd-4170-b1ba-60450b75cae4
$5
30000
$13
1703475309785
$1
1
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$23
{midway-bull}:SysTask:1
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@98e89750-edfd-4170-b1ba-60450b75cae4
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$1
1
$13
1703475309791
$11
returnvalue
$4
null
$36
98e89750-edfd-4170-b1ba-60450b75cae4
$10
Þ ¥count
$13
{"jobId":"1"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
98e89750-edfd-4170-b1ba-60450b75cae4
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703475339785
$5
30000
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703475365100}
$13
1703475365100
$1
0
$1
0
$1
0
$5
LPUSH
$36
7409c830-04cd-4397-8c61-e01bc0f0d6e3
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@7409c830-04cd-4397-8c61-e01bc0f0d6e3
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
7409c830-04cd-4397-8c61-e01bc0f0d6e3
$5
30000
$13
1703475365153
$1
2
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$23
{midway-bull}:SysTask:2
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@7409c830-04cd-4397-8c61-e01bc0f0d6e3
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$1
2
$13
1703475365164
$11
returnvalue
$4
null
$36
7409c830-04cd-4397-8c61-e01bc0f0d6e3
$10
Þ ¥count
$13
{"jobId":"2"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
7409c830-04cd-4397-8c61-e01bc0f0d6e3
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703475395151
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703475455154
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703475485155
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703475570105}
$13
1703475570105
$1
0
$1
0
$1
0
$5
LPUSH
$36
60a7bf3f-a356-4c2c-89e0-26396a94a768
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703475570122
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@60a7bf3f-a356-4c2c-89e0-26396a94a768
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
60a7bf3f-a356-4c2c-89e0-26396a94a768
$5
30000
$13
1703475570128
$1
3
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$23
{midway-bull}:SysTask:3
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@60a7bf3f-a356-4c2c-89e0-26396a94a768
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$1
3
$13
1703475570137
$11
returnvalue
$4
null
$36
60a7bf3f-a356-4c2c-89e0-26396a94a768
$10
Þ ¥count
$13
{"jobId":"3"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
60a7bf3f-a356-4c2c-89e0-26396a94a768
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703475600127
$5
30000
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703475620308}
$13
1703475620308
$1
0
$1
0
$1
0
$5
LPUSH
$36
76ac42f0-7f7a-452b-8a4c-31d3f1c954b4
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@76ac42f0-7f7a-452b-8a4c-31d3f1c954b4
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
76ac42f0-7f7a-452b-8a4c-31d3f1c954b4
$5
30000
$13
1703475620328
$1
4
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$23
{midway-bull}:SysTask:4
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@76ac42f0-7f7a-452b-8a4c-31d3f1c954b4
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$1
4
$13
1703475620340
$11
returnvalue
$4
null
$36
76ac42f0-7f7a-452b-8a4c-31d3f1c954b4
$10
Þ ¥count
$13
{"jobId":"4"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
76ac42f0-7f7a-452b-8a4c-31d3f1c954b4
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703475650326
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703475680328
$5
30000
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703475698761}
$13
1703475698761
$1
0
$1
0
$1
0
$5
LPUSH
$36
bf579569-22bf-4615-b170-9401ce72512f
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@bf579569-22bf-4615-b170-9401ce72512f
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
bf579569-22bf-4615-b170-9401ce72512f
$5
30000
$13
1703475698774
$1
5
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$23
{midway-bull}:SysTask:5
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@bf579569-22bf-4615-b170-9401ce72512f
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$1
5
$13
1703475698783
$11
returnvalue
$4
null
$36
bf579569-22bf-4615-b170-9401ce72512f
$10
Þ ¥count
$13
{"jobId":"5"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
bf579569-22bf-4615-b170-9401ce72512f
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703475728774
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703475758775
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703475788775
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703475818776
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703475848777
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703475908780
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703475938780
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703475968782
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703476028759
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703476084745}
$13
1703476084745
$1
0
$1
0
$1
0
$5
LPUSH
$36
d2659fef-5d79-42f3-b2ea-b8f7da2fb8d1
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703476084762
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@d2659fef-5d79-42f3-b2ea-b8f7da2fb8d1
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
d2659fef-5d79-42f3-b2ea-b8f7da2fb8d1
$5
30000
$13
1703476084769
$1
6
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$23
{midway-bull}:SysTask:6
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@d2659fef-5d79-42f3-b2ea-b8f7da2fb8d1
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$1
6
$13
1703476084777
$11
returnvalue
$4
null
$36
d2659fef-5d79-42f3-b2ea-b8f7da2fb8d1
$10
Þ ¥count
$13
{"jobId":"6"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
d2659fef-5d79-42f3-b2ea-b8f7da2fb8d1
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703476120847}
$13
1703476120847
$1
0
$1
0
$1
0
$5
LPUSH
$36
e3f44a62-b022-4892-879f-47961330e726
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703476120860
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@e3f44a62-b022-4892-879f-47961330e726
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
e3f44a62-b022-4892-879f-47961330e726
$5
30000
$13
1703476120866
$1
7
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$23
{midway-bull}:SysTask:7
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@e3f44a62-b022-4892-879f-47961330e726
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$1
7
$13
1703476120874
$11
returnvalue
$4
null
$36
e3f44a62-b022-4892-879f-47961330e726
$10
Þ ¥count
$13
{"jobId":"7"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
e3f44a62-b022-4892-879f-47961330e726
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703476150865
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703476210867
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703476240867
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703476270868
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703476330869
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703476360869
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703476390871
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703476450874
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703476510875
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703476546374}
$13
1703476546374
$1
0
$1
0
$1
0
$5
LPUSH
$36
73896493-1361-450e-bd68-78242d67fc0b
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703476546524
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@73896493-1361-450e-bd68-78242d67fc0b
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
73896493-1361-450e-bd68-78242d67fc0b
$5
30000
$13
1703476546532
$1
8
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$23
{midway-bull}:SysTask:8
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@73896493-1361-450e-bd68-78242d67fc0b
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$1
8
$13
1703476546547
$11
returnvalue
$4
null
$36
73896493-1361-450e-bd68-78242d67fc0b
$10
Þ ¥count
$13
{"jobId":"8"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
73896493-1361-450e-bd68-78242d67fc0b
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703476576530
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703482986901}
$13
1703482986901
$1
0
$1
0
$1
0
$5
LPUSH
$36
ec8d2859-a059-4ea4-ab2b-f4ee15ad9341
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703482986913
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@ec8d2859-a059-4ea4-ab2b-f4ee15ad9341
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
ec8d2859-a059-4ea4-ab2b-f4ee15ad9341
$5
30000
$13
1703482986918
$1
9
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$23
{midway-bull}:SysTask:9
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@ec8d2859-a059-4ea4-ab2b-f4ee15ad9341
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$1
9
$13
1703482986925
$11
returnvalue
$4
null
$36
ec8d2859-a059-4ea4-ab2b-f4ee15ad9341
$10
Þ ¥count
$13
{"jobId":"9"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
ec8d2859-a059-4ea4-ab2b-f4ee15ad9341
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703483053268}
$13
1703483053268
$1
0
$1
0
$1
0
$5
LPUSH
$36
03030d53-ded4-4f90-8738-c60e0144c2e4
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703483053802
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@03030d53-ded4-4f90-8738-c60e0144c2e4
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
03030d53-ded4-4f90-8738-c60e0144c2e4
$5
30000
$13
1703483053912
$2
10
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:10
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@03030d53-ded4-4f90-8738-c60e0144c2e4
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
10
$13
1703483053929
$11
returnvalue
$4
null
$36
03030d53-ded4-4f90-8738-c60e0144c2e4
$10
Þ ¥count
$14
{"jobId":"10"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
03030d53-ded4-4f90-8738-c60e0144c2e4
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703483083896
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703483113897
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703483171883}
$13
1703483171883
$1
0
$1
0
$1
0
$5
LPUSH
$36
83a2220e-917a-4ee5-b649-2d5909de0be0
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703483171932
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@83a2220e-917a-4ee5-b649-2d5909de0be0
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
83a2220e-917a-4ee5-b649-2d5909de0be0
$5
30000
$13
1703483171954
$2
11
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:11
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@83a2220e-917a-4ee5-b649-2d5909de0be0
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
11
$13
1703483171976
$11
returnvalue
$4
null
$36
83a2220e-917a-4ee5-b649-2d5909de0be0
$10
Þ ¥count
$14
{"jobId":"11"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
83a2220e-917a-4ee5-b649-2d5909de0be0
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703483201943
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703483236344}
$13
1703483236344
$1
0
$1
0
$1
0
$5
LPUSH
$36
eda1cdcc-e9f7-4f79-9927-ae5ff421d5da
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703483236358
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@eda1cdcc-e9f7-4f79-9927-ae5ff421d5da
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
eda1cdcc-e9f7-4f79-9927-ae5ff421d5da
$5
30000
$13
1703483236362
$2
12
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:12
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@eda1cdcc-e9f7-4f79-9927-ae5ff421d5da
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
12
$13
1703483236370
$11
returnvalue
$4
null
$36
eda1cdcc-e9f7-4f79-9927-ae5ff421d5da
$10
Þ ¥count
$14
{"jobId":"12"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
eda1cdcc-e9f7-4f79-9927-ae5ff421d5da
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703483266361
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703483296362
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703483545399}
$13
1703483545399
$1
0
$1
0
$1
0
$5
LPUSH
$36
3dc0486d-cc9e-4435-a9cc-a04341a27c35
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703483545412
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@3dc0486d-cc9e-4435-a9cc-a04341a27c35
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
3dc0486d-cc9e-4435-a9cc-a04341a27c35
$5
30000
$13
1703483545416
$2
13
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:13
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@3dc0486d-cc9e-4435-a9cc-a04341a27c35
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
13
$13
1703483545424
$11
returnvalue
$4
null
$36
3dc0486d-cc9e-4435-a9cc-a04341a27c35
$10
Þ ¥count
$14
{"jobId":"13"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
3dc0486d-cc9e-4435-a9cc-a04341a27c35
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703483575414
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703483605415
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703483635417
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703483665417
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703483701453}
$13
1703483701453
$1
0
$1
0
$1
0
$5
LPUSH
$36
6f08aff1-94d9-4435-8792-ce27ecce7ab8
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703483701461
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@6f08aff1-94d9-4435-8792-ce27ecce7ab8
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
6f08aff1-94d9-4435-8792-ce27ecce7ab8
$5
30000
$13
1703483701466
$2
14
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:14
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@6f08aff1-94d9-4435-8792-ce27ecce7ab8
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
14
$13
1703483701471
$11
returnvalue
$4
null
$36
6f08aff1-94d9-4435-8792-ce27ecce7ab8
$10
Þ ¥count
$14
{"jobId":"14"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
6f08aff1-94d9-4435-8792-ce27ecce7ab8
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703483731464
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703483761465
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703483796379}
$13
1703483796379
$1
0
$1
0
$1
0
$5
LPUSH
$36
e390f6e9-e1fe-4746-b52d-ed4dafdbf2d0
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703483796390
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@e390f6e9-e1fe-4746-b52d-ed4dafdbf2d0
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
e390f6e9-e1fe-4746-b52d-ed4dafdbf2d0
$5
30000
$13
1703483796395
$2
15
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:15
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@e390f6e9-e1fe-4746-b52d-ed4dafdbf2d0
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
15
$13
1703483796404
$11
returnvalue
$4
null
$36
e390f6e9-e1fe-4746-b52d-ed4dafdbf2d0
$10
Þ ¥count
$14
{"jobId":"15"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
e390f6e9-e1fe-4746-b52d-ed4dafdbf2d0
$0

*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703483821158}
$13
1703483821158
$1
0
$1
0
$1
0
$5
LPUSH
$36
fb685bba-234b-4cdd-8444-1f5655bfc579
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@fb685bba-234b-4cdd-8444-1f5655bfc579
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
fb685bba-234b-4cdd-8444-1f5655bfc579
$5
30000
$13
1703483821179
$2
16
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:16
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@fb685bba-234b-4cdd-8444-1f5655bfc579
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
16
$13
1703483821193
$11
returnvalue
$4
null
$36
fb685bba-234b-4cdd-8444-1f5655bfc579
$10
Þ ¥count
$14
{"jobId":"16"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
fb685bba-234b-4cdd-8444-1f5655bfc579
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703483851177
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703483911144
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703484020316}
$13
1703484020316
$1
0
$1
0
$1
0
$5
LPUSH
$36
a9fed3a5-65a0-48d7-80b6-f477b03c594b
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703484020328
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@a9fed3a5-65a0-48d7-80b6-f477b03c594b
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
a9fed3a5-65a0-48d7-80b6-f477b03c594b
$5
30000
$13
1703484020333
$2
17
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:17
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@a9fed3a5-65a0-48d7-80b6-f477b03c594b
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
17
$13
1703484020339
$11
returnvalue
$4
null
$36
a9fed3a5-65a0-48d7-80b6-f477b03c594b
$10
Þ ¥count
$14
{"jobId":"17"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
a9fed3a5-65a0-48d7-80b6-f477b03c594b
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703484050330
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703484100482}
$13
1703484100482
$1
0
$1
0
$1
0
$5
LPUSH
$36
5740ff67-d7aa-43cb-9567-da38c1a680a1
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703484100520
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@5740ff67-d7aa-43cb-9567-da38c1a680a1
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
5740ff67-d7aa-43cb-9567-da38c1a680a1
$5
30000
$13
1703484100529
$2
18
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:18
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@5740ff67-d7aa-43cb-9567-da38c1a680a1
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
18
$13
1703484100545
$11
returnvalue
$4
null
$36
5740ff67-d7aa-43cb-9567-da38c1a680a1
$10
Þ ¥count
$14
{"jobId":"18"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
5740ff67-d7aa-43cb-9567-da38c1a680a1
$0

*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703484114810}
$13
1703484114810
$1
0
$1
0
$1
0
$5
LPUSH
$36
55ebec5a-67c1-4333-840d-8707df4c4558
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@55ebec5a-67c1-4333-840d-8707df4c4558
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
55ebec5a-67c1-4333-840d-8707df4c4558
$5
30000
$13
1703484114833
$2
19
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:19
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@55ebec5a-67c1-4333-840d-8707df4c4558
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
19
$13
1703484114846
$11
returnvalue
$4
null
$36
55ebec5a-67c1-4333-840d-8707df4c4558
$10
Þ ¥count
$14
{"jobId":"19"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
55ebec5a-67c1-4333-840d-8707df4c4558
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703484144830
$5
30000
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703484157362}
$13
1703484157362
$1
0
$1
0
$1
0
$5
LPUSH
$36
ebfe63f6-ad59-42bb-abb0-56ce08292686
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@ebfe63f6-ad59-42bb-abb0-56ce08292686
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
ebfe63f6-ad59-42bb-abb0-56ce08292686
$5
30000
$13
1703484157383
$2
20
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:20
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@ebfe63f6-ad59-42bb-abb0-56ce08292686
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
20
$13
1703484157392
$11
returnvalue
$4
null
$36
ebfe63f6-ad59-42bb-abb0-56ce08292686
$10
Þ ¥count
$14
{"jobId":"20"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
ebfe63f6-ad59-42bb-abb0-56ce08292686
$0

*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703484167350}
$13
1703484167350
$1
0
$1
0
$1
0
$5
LPUSH
$36
2b8a86c0-8d22-4af5-b7a1-cf09b329cd95
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@2b8a86c0-8d22-4af5-b7a1-cf09b329cd95
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
2b8a86c0-8d22-4af5-b7a1-cf09b329cd95
$5
30000
$13
1703484167364
$2
21
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:21
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@2b8a86c0-8d22-4af5-b7a1-cf09b329cd95
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
21
$13
1703484167372
$11
returnvalue
$4
null
$36
2b8a86c0-8d22-4af5-b7a1-cf09b329cd95
$10
Þ ¥count
$14
{"jobId":"21"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
2b8a86c0-8d22-4af5-b7a1-cf09b329cd95
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703484197362
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703484227363
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703484287363
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703484347363
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703484377363
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703484437363
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703484467364
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703484527365
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703484557366
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703484587368
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703484647367
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703484707368
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703484737370
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703484797391
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703484827442
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703484952212
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703485012309
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703485050817}
$13
1703485050817
$1
0
$1
0
$1
0
$5
LPUSH
$36
cfa51aa0-b987-4444-a7f0-cf06ba2db173
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703485050829
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@cfa51aa0-b987-4444-a7f0-cf06ba2db173
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
cfa51aa0-b987-4444-a7f0-cf06ba2db173
$5
30000
$13
1703485050833
$2
22
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:22
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@cfa51aa0-b987-4444-a7f0-cf06ba2db173
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
22
$13
1703485050840
$11
returnvalue
$4
null
$36
cfa51aa0-b987-4444-a7f0-cf06ba2db173
$10
Þ ¥count
$14
{"jobId":"22"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
cfa51aa0-b987-4444-a7f0-cf06ba2db173
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703485080832
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703485110833
$5
30000
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703485136629}
$13
1703485136629
$1
0
$1
0
$1
0
$5
LPUSH
$36
1469132b-aa9c-41c7-bfe6-4a0062972cdf
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@1469132b-aa9c-41c7-bfe6-4a0062972cdf
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
1469132b-aa9c-41c7-bfe6-4a0062972cdf
$5
30000
$13
1703485136648
$2
23
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:23
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@1469132b-aa9c-41c7-bfe6-4a0062972cdf
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
23
$13
1703485136660
$11
returnvalue
$4
null
$36
1469132b-aa9c-41c7-bfe6-4a0062972cdf
$10
Þ ¥count
$14
{"jobId":"23"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
1469132b-aa9c-41c7-bfe6-4a0062972cdf
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703485187741}
$13
1703485187741
$1
0
$1
0
$1
0
$5
LPUSH
$36
0d55fbb3-b3c6-4777-bd84-b5811119f9fb
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703485187760
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@0d55fbb3-b3c6-4777-bd84-b5811119f9fb
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
0d55fbb3-b3c6-4777-bd84-b5811119f9fb
$5
30000
$13
1703485187767
$2
24
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:24
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@0d55fbb3-b3c6-4777-bd84-b5811119f9fb
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
24
$13
1703485187777
$11
returnvalue
$4
null
$36
0d55fbb3-b3c6-4777-bd84-b5811119f9fb
$10
Þ ¥count
$14
{"jobId":"24"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
0d55fbb3-b3c6-4777-bd84-b5811119f9fb
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703485220721}
$13
1703485220721
$1
0
$1
0
$1
0
$5
LPUSH
$36
361f4483-f147-44e4-bdf6-cf35940da2d9
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703485220734
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@361f4483-f147-44e4-bdf6-cf35940da2d9
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
361f4483-f147-44e4-bdf6-cf35940da2d9
$5
30000
$13
1703485220739
$2
25
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:25
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@361f4483-f147-44e4-bdf6-cf35940da2d9
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
25
$13
1703485220749
$11
returnvalue
$4
null
$36
361f4483-f147-44e4-bdf6-cf35940da2d9
$10
Þ ¥count
$14
{"jobId":"25"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
361f4483-f147-44e4-bdf6-cf35940da2d9
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703485250738
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703485542520}
$13
1703485542520
$1
0
$1
0
$1
0
$5
LPUSH
$36
38392468-cb7d-4b25-8572-e6a3b924961f
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703485542533
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@38392468-cb7d-4b25-8572-e6a3b924961f
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
38392468-cb7d-4b25-8572-e6a3b924961f
$5
30000
$13
1703485542536
$2
26
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:26
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@38392468-cb7d-4b25-8572-e6a3b924961f
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
26
$13
1703485542542
$11
returnvalue
$4
null
$36
38392468-cb7d-4b25-8572-e6a3b924961f
$10
Þ ¥count
$14
{"jobId":"26"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
38392468-cb7d-4b25-8572-e6a3b924961f
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703485572536
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703485602537
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703485632537
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703485662538
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703485722540
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703485752542
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703485782543
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703485812545
$5
30000
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703485841869}
$13
1703485841869
$1
0
$1
0
$1
0
$5
LPUSH
$36
1340b733-2d4f-4bce-8174-05d73e40aedb
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@1340b733-2d4f-4bce-8174-05d73e40aedb
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
1340b733-2d4f-4bce-8174-05d73e40aedb
$5
30000
$13
1703485841883
$2
27
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:27
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@1340b733-2d4f-4bce-8174-05d73e40aedb
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
27
$13
1703485841891
$11
returnvalue
$4
null
$36
1340b733-2d4f-4bce-8174-05d73e40aedb
$10
Þ ¥count
$14
{"jobId":"27"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
1340b733-2d4f-4bce-8174-05d73e40aedb
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703485852584}
$13
1703485852584
$1
0
$1
0
$1
0
$5
LPUSH
$36
c18ab29b-5f77-482d-8b0c-54f2556810ba
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703485852592
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@c18ab29b-5f77-482d-8b0c-54f2556810ba
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
c18ab29b-5f77-482d-8b0c-54f2556810ba
$5
30000
$13
1703485852597
$2
28
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:28
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@c18ab29b-5f77-482d-8b0c-54f2556810ba
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
28
$13
1703485852607
$11
returnvalue
$4
null
$36
c18ab29b-5f77-482d-8b0c-54f2556810ba
$10
Þ ¥count
$14
{"jobId":"28"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
c18ab29b-5f77-482d-8b0c-54f2556810ba
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703485883634}
$13
1703485883634
$1
0
$1
0
$1
0
$5
LPUSH
$36
e1526e75-e6d3-4980-9aeb-4e998e59d485
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703485883659
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@e1526e75-e6d3-4980-9aeb-4e998e59d485
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
e1526e75-e6d3-4980-9aeb-4e998e59d485
$5
30000
$13
1703485883669
$2
29
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:29
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@e1526e75-e6d3-4980-9aeb-4e998e59d485
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
29
$13
1703485883683
$11
returnvalue
$4
null
$36
e1526e75-e6d3-4980-9aeb-4e998e59d485
$10
Þ ¥count
$14
{"jobId":"29"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
e1526e75-e6d3-4980-9aeb-4e998e59d485
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703485913663
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703485973650
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703486009943}
$13
1703486009943
$1
0
$1
0
$1
0
$5
LPUSH
$36
f7025dc1-fd10-4adc-8e8e-c533e65bce57
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703486009955
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@f7025dc1-fd10-4adc-8e8e-c533e65bce57
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
f7025dc1-fd10-4adc-8e8e-c533e65bce57
$5
30000
$13
1703486009959
$2
30
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:30
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@f7025dc1-fd10-4adc-8e8e-c533e65bce57
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
30
$13
1703486009965
$11
returnvalue
$4
null
$36
f7025dc1-fd10-4adc-8e8e-c533e65bce57
$10
Þ ¥count
$14
{"jobId":"30"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
f7025dc1-fd10-4adc-8e8e-c533e65bce57
$0

*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703486034076}
$13
1703486034076
$1
0
$1
0
$1
0
$5
LPUSH
$36
e5e54d9a-6076-403d-8c88-389f809330c7
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@e5e54d9a-6076-403d-8c88-389f809330c7
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
e5e54d9a-6076-403d-8c88-389f809330c7
$5
30000
$13
1703486034099
$2
31
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:31
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@e5e54d9a-6076-403d-8c88-389f809330c7
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
31
$13
1703486034106
$11
returnvalue
$4
null
$36
e5e54d9a-6076-403d-8c88-389f809330c7
$10
Þ ¥count
$14
{"jobId":"31"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
e5e54d9a-6076-403d-8c88-389f809330c7
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703486066880}
$13
1703486066880
$1
0
$1
0
$1
0
$5
LPUSH
$36
92d897d8-251a-43ff-8cda-b7eb34be123b
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703486066893
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@92d897d8-251a-43ff-8cda-b7eb34be123b
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
92d897d8-251a-43ff-8cda-b7eb34be123b
$5
30000
$13
1703486066899
$2
32
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:32
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@92d897d8-251a-43ff-8cda-b7eb34be123b
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
32
$13
1703486066909
$11
returnvalue
$4
null
$36
92d897d8-251a-43ff-8cda-b7eb34be123b
$10
Þ ¥count
$14
{"jobId":"32"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
92d897d8-251a-43ff-8cda-b7eb34be123b
$0

*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703486080308}
$13
1703486080308
$1
0
$1
0
$1
0
$5
LPUSH
$36
bdce9b6e-517f-429a-a2de-6e648af032b5
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@bdce9b6e-517f-429a-a2de-6e648af032b5
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
bdce9b6e-517f-429a-a2de-6e648af032b5
$5
30000
$13
1703486080330
$2
33
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:33
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@bdce9b6e-517f-429a-a2de-6e648af032b5
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
33
$13
1703486080341
$11
returnvalue
$4
null
$36
bdce9b6e-517f-429a-a2de-6e648af032b5
$10
Þ ¥count
$14
{"jobId":"33"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
bdce9b6e-517f-429a-a2de-6e648af032b5
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703486110328
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703486144204}
$13
1703486144204
$1
0
$1
0
$1
0
$5
LPUSH
$36
16b66a0a-9055-4328-b72f-a507f3c4737a
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703486144218
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@16b66a0a-9055-4328-b72f-a507f3c4737a
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
16b66a0a-9055-4328-b72f-a507f3c4737a
$5
30000
$13
1703486144222
$2
34
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:34
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@16b66a0a-9055-4328-b72f-a507f3c4737a
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
34
$13
1703486144229
$11
returnvalue
$4
null
$36
16b66a0a-9055-4328-b72f-a507f3c4737a
$10
Þ ¥count
$14
{"jobId":"34"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
16b66a0a-9055-4328-b72f-a507f3c4737a
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703486177499}
$13
1703486177499
$1
0
$1
0
$1
0
$5
LPUSH
$36
7c1337fd-f3d5-412b-a62c-35fc4596e4eb
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703486177519
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@7c1337fd-f3d5-412b-a62c-35fc4596e4eb
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
7c1337fd-f3d5-412b-a62c-35fc4596e4eb
$5
30000
$13
1703486177530
$2
35
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:35
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@7c1337fd-f3d5-412b-a62c-35fc4596e4eb
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
35
$13
1703486177543
$11
returnvalue
$4
null
$36
7c1337fd-f3d5-412b-a62c-35fc4596e4eb
$10
Þ ¥count
$14
{"jobId":"35"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
7c1337fd-f3d5-412b-a62c-35fc4596e4eb
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703486207528
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703486237530
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703486267531
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703486297532
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703486357533
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703486387535
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703486417537
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*14
$7
evalsha
$40
b52af7a3cde0f20cb48835a1b09863b1d5bf05b7
$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703486477538
$5
30000
*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703486579360}
$13
1703486579360
$1
0
$1
0
$1
0
$5
LPUSH
$36
39a64ea5-db74-49f3-a19a-963263eb3b03
*14
$4
eval
$2640
--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)

      KEYS[6] 'meta-paused', (KEY)
      KEYS[7] 'paused', (LIST)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]

local rcall = redis.call

local function batches(n, batchSize)
  local i = 0

  return function()
    local from = i * batchSize + 1
    i = i + 1
    if (from <= n) then
      local to = math.min(from + batchSize - 1, n)
      return from, to
    end
  end
end

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then
  return {{}, {}}
end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if(#stalling > 0) then

  local dst
  -- wait or paused destination
  if rcall("EXISTS", KEYS[6]) ~= 1 then
    dst = KEYS[2]
  else
    dst = KEYS[7]
  end

  rcall('DEL', KEYS[1])

  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

  -- Remove from active list
  for i, jobId in ipairs(stalling) do
    local jobKey = ARGV[2] .. jobId

    -- Check that the lock is also missing, then we can handle this job as really stalled.
    if(rcall("EXISTS", jobKey .. ":lock") == 0) then
      --  Remove from the active queue.
      local removed = rcall("LREM", KEYS[3], 1, jobId)

      if(removed > 0) then
        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
        local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter", 1)
        if(stalledCount > MAX_STALLED_JOB_COUNT) then
          rcall("ZADD", KEYS[4], ARGV[3], jobId)
          rcall("HSET", jobKey, "failedReason", "job stalled more than allowable limit")
          rcall("PUBLISH", KEYS[4],  "{\"jobId\":\"" .. jobId .. "\", \"val\": \"job stalled more than maxStalledCount\"}")
          table.insert(failed, jobId)
        else
          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
          rcall("RPUSH", dst, jobId)
          rcall('PUBLISH', KEYS[1] .. '@', jobId)
          table.insert(stalled, jobId)
        end
      end
    end
  end
end

-- Mark potentially stalled jobs
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}

$1
7
$29
{midway-bull}:SysTask:stalled
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$28
{midway-bull}:SysTask:failed
$35
{midway-bull}:SysTask:stalled-check
$33
{midway-bull}:SysTask:meta-paused
$28
{midway-bull}:SysTask:paused
$1
1
$22
{midway-bull}:SysTask:
$13
1703486579420
$5
30000
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@39a64ea5-db74-49f3-a19a-963263eb3b03
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
39a64ea5-db74-49f3-a19a-963263eb3b03
$5
30000
$13
1703486579427
$2
36
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:36
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@39a64ea5-db74-49f3-a19a-963263eb3b03
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
36
$13
1703486579439
$11
returnvalue
$4
null
$36
39a64ea5-db74-49f3-a19a-963263eb3b03
$10
Þ ¥count
$14
{"jobId":"36"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
39a64ea5-db74-49f3-a19a-963263eb3b03
$0

*20
$4
eval
$2695
--[[
  Adds a job to the queue by doing the following:
    - Increases the job counter if needed.
    - Creates a new job key with the job data.

    - if delayed:
      - computes timestamp.
      - adds to delayed zset.
      - Emits a global event 'delayed' if the job is delayed.
    - if not delayed
      - Adds the jobId to the wait/paused list in one of three ways:
         - LIFO
         - FIFO
         - prioritized.
      - Adds the job to the "added" list so that workers gets notified.

    Input:
      KEYS[1] 'wait',
      KEYS[2] 'paused'
      KEYS[3] 'meta-paused'
      KEYS[4] 'id'
      KEYS[5] 'delayed'
      KEYS[6] 'priority'

      ARGV[1]  key prefix,
      ARGV[2]  custom id (will not generate one automatically)
      ARGV[3]  name
      ARGV[4]  data (json stringified job data)
      ARGV[5]  opts (json stringified job opts)
      ARGV[6]  timestamp
      ARGV[7]  delay
      ARGV[8]  delayedTimestamp
      ARGV[9]  priority
      ARGV[10] LIFO
      ARGV[11] token
]]
local jobId
local jobIdKey
local rcall = redis.call

local jobCounter = rcall("INCR", KEYS[4])

if ARGV[2] == "" then
  jobId = jobCounter
  jobIdKey = ARGV[1] .. jobId
else
  jobId = ARGV[2]
  jobIdKey = ARGV[1] .. jobId
  if rcall("EXISTS", jobIdKey) == 1 then
    return jobId .. "" -- convert to string
  end
end

-- Store the job.
rcall("HMSET", jobIdKey, "name", ARGV[3], "data", ARGV[4], "opts", ARGV[5], "timestamp", ARGV[6], "delay", ARGV[7], "priority", ARGV[9])

-- Check if job is delayed
local delayedTimestamp = tonumber(ARGV[8])
if(delayedTimestamp ~= 0) then
  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)
  rcall("ZADD", KEYS[5], timestamp, jobId)
  rcall("PUBLISH", KEYS[5], delayedTimestamp)
else
  local target

  -- Whe check for the meta-paused key to decide if we are paused or not
  -- (since an empty list and !EXISTS are not really the same)
  local paused
  if rcall("EXISTS", KEYS[3]) ~= 1 then
    target = KEYS[1]
    paused = false
  else
    target = KEYS[2]
    paused = true
  end

  -- Standard or priority add
  local priority = tonumber(ARGV[9])
  if priority == 0 then
      -- LIFO or FIFO
    rcall(ARGV[10], target, jobId)
  else
    -- Priority add
    rcall("ZADD", KEYS[6], priority, jobId)
    local count = rcall("ZCOUNT", KEYS[6], 0, priority)

    local len = rcall("LLEN", target)
    local id = rcall("LINDEX", target, len - (count-1))
    if id then
      rcall("LINSERT", target, "BEFORE", id, jobId)
    else
      rcall("RPUSH", target, jobId)
    end

  end

  -- Emit waiting event (wait..ing@token)
  rcall("PUBLISH", KEYS[1] .. "ing@" .. ARGV[11], jobId)
end

return jobId .. "" -- convert to string

$1
6
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:paused
$33
{midway-bull}:SysTask:meta-paused
$24
{midway-bull}:SysTask:id
$29
{midway-bull}:SysTask:delayed
$30
{midway-bull}:SysTask:priority
$22
{midway-bull}:SysTask:
$0

$11
__default__
$22
{"name":"hello world"}
$89
{"removeOnComplete":3,"removeOnFail":10,"attempts":1,"delay":0,"timestamp":1703486600781}
$13
1703486600781
$1
0
$1
0
$1
0
$5
LPUSH
$36
f7f0921b-4ad3-4eaa-a524-9501a17ce8bc
*3
$9
RPOPLPUSH
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
*16
$4
eval
$4573
--[[
  Move next job to be processed to active, lock it and fetch its data. The job
  may be delayed, in that case we need to move it to the delayed set instead.

  This operation guarantees that the worker owns the job during the locks
  expiration time. The worker is responsible of keeping the lock fresh
  so that no other worker picks this job again.

  Input:
      KEYS[1] wait key
      KEYS[2] active key
      KEYS[3] priority key
      KEYS[4] active event key
      KEYS[5] stalled key

      -- Rate limiting
      KEYS[6] rate limiter key
      KEYS[7] delayed key

      --
      KEYS[8] drained key

      ARGV[1] key prefix
      ARGV[2] lock token
      ARGV[3] lock duration in milliseconds
      ARGV[4] timestamp
      ARGV[5] optional jobid

      ARGV[6] optional jobs per time unit (rate limiter)
      ARGV[7] optional time unit (rate limiter)
      ARGV[8] optional do not do anything with job if rate limit hit
      ARGV[9] optional rate limit by key
]]

local rcall = redis.call

local rateLimit = function(jobId, maxJobs)
  local rateLimiterKey = KEYS[6];
  local limiterIndexTable = rateLimiterKey .. ":index"

  -- Rate limit by group?
  if(ARGV[9]) then
    local group = string.match(jobId, "[^:]+$")
    if group ~= nil then
      rateLimiterKey = rateLimiterKey .. ":" .. group
    end
  end

  -- -- key for storing rate limited jobs
  -- When a job has been previously rate limited it should be part of this set
  -- if the job is back here means that the delay time for this job has passed and now we should
  -- be able to process it again.
  local limitedSetKey = rateLimiterKey .. ":limited"
  local delay = 0

  -- -- Check if job was already limited
  local isLimited = rcall("SISMEMBER", limitedSetKey, jobId);

  if isLimited == 1 then
     -- Remove from limited zset since we are going to try to process it
     rcall("SREM", limitedSetKey, jobId)
     rcall("HDEL", limiterIndexTable, jobId)
  else
    -- If not, check if there are any limited jobs
    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that
    -- is the case we do not want to process this job, just calculate a delay for it and put it to "sleep".
    local numLimitedJobs = rcall("SCARD", limitedSetKey)

    if numLimitedJobs > 0 then
      -- Note, add some slack to compensate for drift.
      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall("PTTL", rateLimiterKey))
    end
  end

  local jobCounter = tonumber(rcall("GET", rateLimiterKey))
  if(jobCounter == nil) then
    jobCounter = 0
  end
  -- check if rate limit hit
  if (delay == 0) and (jobCounter >= maxJobs) then
    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.
    local exceedingJobs = jobCounter - maxJobs
    delay = tonumber(rcall("PTTL", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs
  end

  if delay > 0 then
    local bounceBack = ARGV[8]
    if bounceBack == 'false' then
      local timestamp = delay + tonumber(ARGV[4])
      -- put job into delayed queue
      rcall("ZADD", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)
      rcall("PUBLISH", KEYS[7], timestamp)
      rcall("SADD", limitedSetKey, jobId)

      -- store index so that we can delete rate limited data
      rcall("HSET", limiterIndexTable, jobId, limitedSetKey)

    end

    -- remove from active queue
    rcall("LREM", KEYS[2], 1, jobId)
    return true
  else
    -- false indicates not rate limited
    -- increment jobCounter only when a job is not rate limited
    if (jobCounter == 0) then
      rcall("PSETEX", rateLimiterKey, ARGV[7], 1)
    else
      rcall("INCR", rateLimiterKey)
    end
    return false
  end
end

local jobId = ARGV[5]

if jobId ~= '' then
  -- clean stalled key
  rcall("SREM", KEYS[5], jobId)
else
  -- move from wait to active
  jobId = rcall("RPOPLPUSH", KEYS[1], KEYS[2])
end

if jobId then
  -- Check if we need to perform rate limiting.
  local maxJobs = tonumber(ARGV[6])

  if maxJobs then
    if rateLimit(jobId, maxJobs) then
       return
    end
  end

  -- get a lock
  local jobKey = ARGV[1] .. jobId
  local lockKey = jobKey .. ':lock'
  rcall("SET", lockKey, ARGV[2], "PX", ARGV[3])

  -- remove from priority
  rcall("ZREM", KEYS[3], jobId)
  rcall("PUBLISH", KEYS[4], jobId)
  rcall("HSET", jobKey, "processedOn", ARGV[4])

  return {rcall("HGETALL", jobKey), jobId} -- get job data
else
  rcall("PUBLISH", KEYS[8], "")
end


$1
8
$26
{midway-bull}:SysTask:wait
$28
{midway-bull}:SysTask:active
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@f7f0921b-4ad3-4eaa-a524-9501a17ce8bc
$29
{midway-bull}:SysTask:stalled
$29
{midway-bull}:SysTask:limiter
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:drained
$22
{midway-bull}:SysTask:
$36
f7f0921b-4ad3-4eaa-a524-9501a17ce8bc
$5
30000
$13
1703486600801
$2
37
*24
$4
eval
$5018
--[[
  Move job from active to a finished status (completed or failed)
  A job can only be moved to completed if it was active.
  The job must be locked before it can be moved to a finished status,
  and the lock must be released in this script.

     Input:
      KEYS[1] active key
      KEYS[2] completed/failed key
      KEYS[3] jobId key

      KEYS[4] wait key
      KEYS[5] priority key
      KEYS[6] active event key

      KEYS[7] delayed key
      KEYS[8] stalled key

      KEYS[9] metrics key

      ARGV[1]  jobId
      ARGV[2]  timestamp
      ARGV[3]  msg property
      ARGV[4]  return value / failed reason
      ARGV[5]  token
      ARGV[6]  shouldRemove
      ARGV[7]  event data (? maybe just send jobid).
      ARGV[8]  should fetch next job
      ARGV[9]  base key
      ARGV[10] lock token
      ARGV[11] lock duration in milliseconds
      ARGV[12] maxMetricsSize

     Output:
      0 OK
      -1 Missing key.
      -2 Missing lock.

     Events:
      'completed/failed'
]]
local rcall = redis.call

--[[
  Functions to collect metrics based on a current and previous count of jobs.
  Granualarity is fixed at 1 minute.
]]
local function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)
    -- Increment current count
    local count = rcall("HINCRBY", metaKey, "count", 1) - 1

    -- Compute how many data points we need to add to the list, N.
    local prevTS = rcall("HGET", metaKey, "prevTS")

    if not prevTS then
        -- If prevTS is nil, set it to the current timestamp
        rcall("HSET", metaKey, "prevTS", timestamp, "prevCount", 0)
        return
    end

    local N = math.floor((timestamp - prevTS) / 60000)

    if N > 0 then
        local delta = count - rcall("HGET", metaKey, "prevCount")
        -- If N > 1, add N-1 zeros to the list
        if N > 1 then
            local points = {}
            points[1] = delta
            for i = 2, N do points[i] = 0 end
            rcall("LPUSH", dataPointsList, unpack(points))
        else
            -- LPUSH delta to the list
            rcall("LPUSH", dataPointsList, delta)
        end

        -- LTRIM to keep list to its max size
        rcall("LTRIM", dataPointsList, 0, maxDataPoints - 1)

        -- update prev count with current count
        rcall("HSET", metaKey, "prevCount", count, "prevTS", timestamp)
    end
end

if rcall("EXISTS", KEYS[3]) == 1 then -- // Make sure job exists
    if ARGV[5] ~= "0" then
        local lockKey = KEYS[3] .. ':lock'
        if rcall("GET", lockKey) == ARGV[5] then
            rcall("DEL", lockKey)
            rcall("SREM", KEYS[8], ARGV[1])
        else
            return -2
        end
    end

    -- Remove from active list
    rcall("LREM", KEYS[1], -1, ARGV[1])

    -- Remove job?
    local keepJobs = cmsgpack.unpack(ARGV[6])
    local maxCount = keepJobs['count']
    local maxAge = keepJobs['age']
    local targetSet = KEYS[2]
    local timestamp = ARGV[2]

    if maxCount ~= 0 then

        -- Add to complete/failed set
        rcall("ZADD", targetSet, timestamp, ARGV[1])
        rcall("HMSET", KEYS[3], ARGV[3], ARGV[4], "finishedOn", timestamp) -- "returnvalue" / "failedReason" and "finishedOn"

        local function removeJobs(jobIds)
            for i, jobId in ipairs(jobIds) do
                local jobKey = ARGV[9] .. jobId
                local jobLogKey = jobKey .. ':logs'
                rcall("DEL", jobKey, jobLogKey)
            end
        end

        -- Remove old jobs?
        if maxAge ~= nil then
            local start = timestamp - maxAge * 1000
            local jobIds = rcall("ZREVRANGEBYSCORE", targetSet, start, "-inf")
            removeJobs(jobIds)
            rcall("ZREMRANGEBYSCORE", targetSet, "-inf", start)
        end

        if maxCount ~= nil and maxCount > 0 then
            local start = maxCount
            local jobIds = rcall("ZREVRANGE", targetSet, start, -1)
            removeJobs(jobIds)
            rcall("ZREMRANGEBYRANK", targetSet, 0, -(maxCount + 1));
        end
    else
        local jobLogKey = KEYS[3] .. ':logs'
        rcall("DEL", KEYS[3], jobLogKey)
    end

    -- Collect metrics
    if ARGV[12] ~= "" then
      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)
    end

    rcall("PUBLISH", targetSet, ARGV[7])

    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, 
    -- and not rate limited.
    if (ARGV[8] == "1") then
        -- move from wait to active 
        local jobId = rcall("RPOPLPUSH", KEYS[4], KEYS[1])
        if jobId then
            local jobKey = ARGV[9] .. jobId
            local lockKey = jobKey .. ':lock'

            -- get a lock
            rcall("SET", lockKey, ARGV[11], "PX", ARGV[10])

            rcall("ZREM", KEYS[5], jobId) -- remove from priority
            rcall("PUBLISH", KEYS[6], jobId)
            rcall("HSET", jobKey, "processedOn", ARGV[2])

            return {rcall("HGETALL", jobKey), jobId} -- get job data
        end
    end

    return 0
else
    return -1
end

$1
9
$28
{midway-bull}:SysTask:active
$31
{midway-bull}:SysTask:completed
$24
{midway-bull}:SysTask:37
$26
{midway-bull}:SysTask:wait
$30
{midway-bull}:SysTask:priority
$65
{midway-bull}:SysTask:active@f7f0921b-4ad3-4eaa-a524-9501a17ce8bc
$29
{midway-bull}:SysTask:delayed
$29
{midway-bull}:SysTask:stalled
$39
{midway-bull}:SysTask:metrics:completed
$2
37
$13
1703486600808
$11
returnvalue
$4
null
$36
f7f0921b-4ad3-4eaa-a524-9501a17ce8bc
$10
Þ ¥count
$14
{"jobId":"37"}
$1
1
$22
{midway-bull}:SysTask:
$5
30000
$36
f7f0921b-4ad3-4eaa-a524-9501a17ce8bc
$0

*2
$3
DEL
$35
{midway-bull}:SysTask:stalled-check
